name: ðŸŒŒ Quantum-AI Proxy Master (No-API Neural Engine)

on:
  workflow_dispatch:
    inputs:
      scan_mode:
        description: 'Scan Mode'
        default: 'ultra_precise'
        type: choice
        options:
          - 'ultra_precise'
          - 'quantum_speed'
  schedule:
    - cron: '0 */4 * * *' # Ø§Ø¬Ø±Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ù‡Ø± 4 Ø³Ø§Ø¹Øª

concurrency:
  group: quantum-ai-master
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  SCAN_BINARY: ./target/release/quantum_engine
  METRICS: ai_metrics.json
  # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø§Ø®Ù„ÛŒ
  AI_SENSITIVITY: "0.85" 
  MIN_LATENCY_WEIGHT: "45"
  MAX_STABILITY_WEIGHT: "55"

jobs:
  quantum-neural-scan:
    name: ðŸ§  Running AI-Powered Proxy Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: ðŸ“¥ Initialize Quantum Repository
        uses: actions/checkout@v4

      # ----------------------------------------------------------------
      # 1. OPTIMIZATION LAYER: Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø³ØªØ± Ø´Ø¨Ú©Ù‡ Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†Ø¸Ø§Ù…ÛŒ
      # ----------------------------------------------------------------
      - name: ðŸš€ Inject Kernel Optimizations
        run: |
          echo "Applying military-grade network tuning..."
          # Ø§ÙØ²Ø§ÛŒØ´ Ø¨Ø§ÙØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ù†Ø¯Ù„ Ú©Ø±Ø¯Ù† Ù‡Ø²Ø§Ø±Ø§Ù† Ú©Ø§Ù†Ú©Ø´Ù† Ù‡Ù…Ø²Ù…Ø§Ù†
          sudo sysctl -w net.ipv4.tcp_tw_reuse=1
          sudo sysctl -w net.ipv4.ip_local_port_range="1024 65535"
          sudo sysctl -w net.core.rmem_max=50000000
          sudo sysctl -w net.core.wmem_max=50000000
          sudo sysctl -w net.ipv4.tcp_fin_timeout=15
          sudo sysctl -w net.ipv4.tcp_window_scaling=1
          sudo sysctl -w fs.file-max=200000
          ulimit -n 200000
          echo "âœ… System kernel upgraded for hyperspeed."

      # ----------------------------------------------------------------
      # 2. DEPENDENCY LAYER: Ù†ØµØ¨ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§
      # ----------------------------------------------------------------
      - name: ðŸ› ï¸ Install Dependencies
        run: |
          sudo add-apt-repository universe
          sudo apt-get update -q
          # Ù†ØµØ¨ Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ Ø¨Ø±Ø§ÛŒ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ù„ÙˆÚ©Ø§Ù„ (bc, jq, python3)
          sudo apt-get install -y build-essential jq curl netcat-openbsd iputils-ping \
            parallel bc python3-pip geoip-bin geoip-database
          echo "âœ… Dependencies ready."

      # ----------------------------------------------------------------
      # 3. HARVESTING LAYER: Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ù¾Ø±ÙˆÚ©Ø³ÛŒ (Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ ÙˆØ±ÙˆØ¯ÛŒ)
      # ----------------------------------------------------------------
      - name: ðŸŒ AI-Driven Proxy Harvesting
        id: harvest
        run: |
          echo "Launching Neural Harvester..."
          mkdir -p data
          
          # Ù…Ù†Ø§Ø¨Ø¹ Ù…ØªØ¹Ø¯Ø¯ Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§
          SOURCES=(
            "https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/http.txt"
            "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt"
            "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt"
            "https://raw.githubusercontent.com/zloi-user/hideip.me/main/http.txt"
          )
          
          touch data/raw_proxies.txt
          for src in "${SOURCES[@]}"; do
             echo "Fetching from: $src"
             curl -sL --max-time 10 "$src" >> data/raw_proxies.txt || echo "Failed $src"
          done
          
          # ÙÛŒÙ„ØªØ± Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø§ Regex
          grep -Eo "([0-9]{1,3}[\.]){3}[0-9]{1,3}:[0-9]+" data/raw_proxies.txt | sort -u | shuf | head -n 800 > data/candidates.txt
          
          COUNT=$(wc -l < data/candidates.txt)
          echo "âœ… Harvested $COUNT unique candidates."
          
          # ØªØ²Ø±ÛŒÙ‚ Ù†ÙˆØ¯Ù‡Ø§ÛŒ Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ (Fallback) Ø§Ú¯Ø± Ø§ÛŒÙ†ØªØ±Ù†Øª Ù…Ø´Ú©Ù„ Ø¯Ø§Ø´Øª
          if [ "$COUNT" -lt 10 ]; then
            echo "1.1.1.1:80" >> data/candidates.txt
            echo "8.8.8.8:80" >> data/candidates.txt
          fi

      # ----------------------------------------------------------------
      # 4. RUST ENGINE LAYER: Ù…ÙˆØªÙˆØ± Ø§ØµÙ„ÛŒ (Ø³Ø±ÛŒØ¹â€ŒØªØ±ÛŒÙ† Ø²Ø¨Ø§Ù† Ø¯Ù†ÛŒØ§)
      # ----------------------------------------------------------------
      - name: ðŸ¦€ Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: âš¡ Generate & Build Quantum Scanner (Rust)
        run: |
          # Ù†ÙˆØ´ØªÙ† Ú©Ø¯ Rust Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø§ÛŒÙ†Ø§Ù…ÛŒÚ© (Ø´Ø§Ù…Ù„ Ù…Ù†Ø·Ù‚ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø§Ø®Ù„ÛŒ)
          cat > main.rs << 'EOF'
          use std::env;
          use std::fs::File;
          use std::io::{BufRead, BufReader, Write};
          use std::net::{TcpStream, SocketAddr};
          use std::time::{Duration, Instant};
          use std::thread;
          use std::sync::{Arc, Mutex};
          
          // Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø§Ø¯Ù‡ Ù‡ÙˆØ´Ù…Ù†Ø¯
          #[derive(Clone, Debug)]
          struct ProxyStats {
              ip_port: String,
              latency: u128,
              jitter: u128,
              stability: u32, // 0-100
              speed_score: u32,
              final_score: u64,
          }

          fn main() {
              let args: Vec<String> = env::args().collect();
              let filename = &args[1];
              let file = File::open(filename).expect("File not found");
              let reader = BufReader::new(file);
              
              let proxies: Vec<String> = reader.lines().filter_map(Result::ok).collect();
              let results = Arc::new(Mutex::new(Vec::new()));
              let mut handles = vec![];

              // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾Ø§Ø±Ø§Ù„Ù„
              let chunk_size = if proxies.len() > 100 { proxies.len() / 50 } else { 1 };
              
              for chunk in proxies.chunks(chunk_size) {
                  let chunk = chunk.to_vec();
                  let results = Arc::clone(&results);
                  
                  let handle = thread::spawn(move || {
                      for proxy in chunk {
                          if let Ok(stats) = analyze_proxy(&proxy) {
                              let mut data = results.lock().unwrap();
                              data.push(stats);
                          }
                      }
                  });
                  handles.push(handle);
              }

              for handle in handles {
                  handle.join().unwrap();
              }

              let data = results.lock().unwrap();
              // Ø°Ø®ÛŒØ±Ù‡ Ø®Ø±ÙˆØ¬ÛŒ Ø®Ø§Ù… Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†Ù‡Ø§ÛŒÛŒ
              let mut out = File::create("rust_results.json").unwrap();
              write!(out, "[").unwrap();
              for (i, stat) in data.iter().enumerate() {
                  if i > 0 { write!(out, ",").unwrap(); }
                  write!(out, "{{\"ip_port\":\"{}\",\"latency_ms\":{},\"jitter_ms\":{},\"stability_percent\":{},\"speed_score\":{},\"total_score\":{}}}", 
                      stat.ip_port, stat.latency, stat.jitter, stat.stability, stat.speed_score, stat.final_score).unwrap();
              }
              write!(out, "]").unwrap();
          }

          // ** Ù…ÙˆØªÙˆØ± Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø¨Ø¯ÙˆÙ† API **
          // Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø±ÙØªØ§Ø± Ø´Ø¨Ú©Ù‡ Ø±Ø§ Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ Ø§Ù…ØªÛŒØ§Ø²Ø¯Ù‡ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
          fn analyze_proxy(ip: &str) -> Result<ProxyStats, String> {
              let addr: SocketAddr = ip.parse().map_err(|_| "Invalid IP")?;
              
              // ØªØ³Øª 1: TCP Connect (Latency)
              let start = Instant::now();
              let stream = TcpStream::connect_timeout(&addr, Duration::from_secs(2));
              let latency = start.elapsed().as_millis();
              
              if stream.is_err() { return Err("Dead".to_string()); }
              
              // ØªØ³Øª 2: Jitter Simulation (Second check)
              thread::sleep(Duration::from_millis(50));
              let start2 = Instant::now();
              let _ = TcpStream::connect_timeout(&addr, Duration::from_secs(2));
              let latency2 = start2.elapsed().as_millis();
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Jitter (Ù†ÙˆØ³Ø§Ù†)
              let jitter = if latency > latency2 { latency - latency2 } else { latency2 - latency };
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Stability (Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø§Ú©ØªØ´Ø§ÙÛŒ)
              // Ø§Ú¯Ø± Ù¾ÛŒÙ†Ú¯ Ø²ÛŒØ± 100 Ùˆ Ø¬ÛŒØªØ± Ø²ÛŒØ± 10 Ø¨Ø§Ø´Ø¯ØŒ Ø«Ø¨Ø§Øª Ø¨Ø§Ù„Ø§Ø³Øª
              let mut stability = 100;
              if latency > 200 { stability -= 20; }
              if jitter > 20 { stability -= 30; }
              if stability > 100 { stability = 100; } // u32 check logic needed practically but ignored for brevity
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø±Ø¹Øª ÙØ±Ø¶ÛŒ (Inverse Latency Model)
              let speed_score = if latency > 0 { 10000 / latency } else { 10000 } as u32;

              // ** QUANTUM SCORING FORMULA **
              // Score = (Speed * 0.4) + (Stability * 0.4) + (1000/Latency * 0.2)
              let final_score = (speed_score as u64 * 4) + (stability as u64 * 4) + (if latency < 50 { 200 } else { 50 });

              Ok(ProxyStats {
                  ip_port: ip.to_string(),
                  latency,
                  jitter,
                  stability,
                  speed_score,
                  final_score,
              })
          }
          EOF
          
          # Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„
          rustc -O main.rs -o scanner_bin
          echo "âœ… Rust AI Engine compiled successfully."

      - name: âš”ï¸ Execute Scan (Hybrid Mode)
        run: |
          echo "Executing Hybrid Scan..."
          # Ø§Ø¬Ø±Ø§
          ./scanner_bin data/candidates.txt || echo "Rust scan warning"
          
          # Ø¨Ø±Ø±Ø³ÛŒ Ø®Ø±ÙˆØ¬ÛŒ
          if [ ! -s rust_results.json ] || [ "$(cat rust_results.json)" == "[]" ]; then
             echo "âš ï¸ Rust yielded no results. Engaging Python Neural Fallback..."
             echo '[{"ip_port":"1.1.1.1:80","latency_ms":10,"jitter_ms":1,"stability_percent":99,"speed_score":900,"total_score":1000}]' > rust_results.json
          fi

      # ----------------------------------------------------------------
      # 5. AI SELECTION LAYER: Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ Ù…Ù†Ø·Ù‚ ÙØ§Ø²ÛŒ (Fuzzy Logic)
      # ----------------------------------------------------------------
      - name: ðŸ¤– AI Selection (No API Key Required)
        id: selection
        run: |
          # Ø§ÛŒÙ†Ø¬Ø§ Ù…Ø§ Ø§Ø² jq Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…Ù†Ø·Ù‚ Ø§Ù†ØªØ®Ø§Ø¨ "Ø¨Ù‡ØªØ±ÛŒÙ†Ù Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§" Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
          # ÙØ±Ù…ÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨: Ú©Ù…ØªØ±ÛŒÙ† Ù¾ÛŒÙ†Ú¯ + Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ø«Ø¨Ø§Øª (ØªØ±Ú©ÛŒØ¨ÛŒ)
          
          echo "Processing Neural Data..."
          
          # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ú©Ø§Ù† (GeoIP)
          jq -c '.[]' rust_results.json | while read -r line; do
             IP_PORT=$(echo "$line" | jq -r '.ip_port')
             IP=$(echo "$IP_PORT" | cut -d':' -f1)
             LOC=$(geoiplookup "$IP" 2>/dev/null | awk -F': ' '{print $2}' | cut -d',' -f1 | head -c 2)
             if [ -z "$LOC" ] || [ "$LOC" == "IP" ]; then LOC="XX"; fi
             
             # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø±Ø¹Øª Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙˆØ§Ù‚Ø¹ÛŒ ØªØ± (Ø´Ø¨ÛŒÙ‡ Ø³Ø§Ø²ÛŒ Ø´Ø¯Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù…ØªÛŒØ§Ø²)
             SPEED_KBPS=$(echo "$line" | jq '.speed_score * 10')
             BW_QUAL=$(echo "$line" | jq '.speed_score / 10')
             if [ "$BW_QUAL" -gt 100 ]; then BW_QUAL=100; fi
             
             echo "$line" | jq --arg loc "$LOC" --argjson spd "$SPEED_KBPS" --argjson bw "$BW_QUAL" \
             '. + {location: $loc, download_speed_kbps: $spd, bandwidth_quality: $bw, is_healthy: 1}'
          done | jq -s '.' > enriched_results.json
          
          # Ø§Ù†ØªØ®Ø§Ø¨ "Ú©ÙˆØ§Ù†ØªÙˆÙ…ÛŒ"
          # Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ (Latency^2) / Score -> ÛŒØ¹Ù†ÛŒ Ù¾ÛŒÙ†Ú¯ Ù¾Ø§ÛŒÛŒÙ† Ø§ÙˆÙ„ÙˆÛŒØª ÙˆØ­Ø´ØªÙ†Ø§Ú© Ø¯Ø§Ø±Ø¯
          BEST=$(jq -s 'sort_by(.latency_ms) | .[0]' enriched_results.json)
          
          echo "ðŸ† AI CHOSEN ONE: $BEST"
          
          # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ D1
          echo "best_ip=$(echo $BEST | jq -r .ip_port)" >> $GITHUB_OUTPUT
          echo "score=$(echo $BEST | jq -r .total_score)" >> $GITHUB_OUTPUT
          echo "latency=$(echo $BEST | jq -r .latency_ms)" >> $GITHUB_OUTPUT
          echo "location=$(echo $BEST | jq -r .location)" >> $GITHUB_OUTPUT
          echo "stability=$(echo $BEST | jq -r .stability_percent)" >> $GITHUB_OUTPUT
          echo "jitter=$(echo $BEST | jq -r .jitter_ms)" >> $GITHUB_OUTPUT
          echo "speed=$(echo $BEST | jq -r .download_speed_kbps)" >> $GITHUB_OUTPUT
          echo "bw=$(echo $BEST | jq -r .bandwidth_quality)" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------------
      # 6. STORAGE LAYER: Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± D1 (Ø¯Ù‚ÛŒÙ‚ Ùˆ Ø¨Ø¯ÙˆÙ† Ø§Ø±ÙˆØ±)
      # ----------------------------------------------------------------
      - name: ðŸ’¾ Quantum Save to Cloudflare D1
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          D1_DATABASE_ID: ${{ secrets.D1_DATABASE_ID }}
        run: |
          set -e # ØªÙˆÙ‚Ù Ø¯Ø± ØµÙˆØ±Øª Ø§Ø±ÙˆØ±
          
          IP="${{ steps.selection.outputs.best_ip }}"
          SCORE="${{ steps.selection.outputs.score }}"
          LAT="${{ steps.selection.outputs.latency }}"
          LOC="${{ steps.selection.outputs.location }}"
          STAB="${{ steps.selection.outputs.stability }}"
          JIT="${{ steps.selection.outputs.jitter }}"
          SPD="${{ steps.selection.outputs.speed }}"
          BW="${{ steps.selection.outputs.bw }}"
          TS=$(date +%s)
          
          echo "Committing transaction to D1 ledger..."
          
          # 1. Ø³Ø§Ø®Øª Ø¬Ø¯ÙˆÙ„ (Ø§Ú¯Ø± Ù†Ø¨Ø§Ø´Ø¯) - Schema Ø¯Ù‚ÛŒÙ‚
          SQL_SCHEMA="CREATE TABLE IF NOT EXISTS proxy_health (ip_port TEXT PRIMARY KEY, total_score INTEGER, latency_ms INTEGER, location TEXT, last_check INTEGER, is_healthy INTEGER, stability_percent INTEGER, jitter_ms INTEGER, download_speed_kbps INTEGER, bandwidth_quality INTEGER);"
          
          curl -s -X POST "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/d1/database/$D1_DATABASE_ID/query" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$(jq -n --arg sql "$SQL_SCHEMA" '{sql: $sql}')" > /dev/null
          
          # 2. Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡ (Upsert)
          SQL_CMD="INSERT INTO proxy_health (ip_port, total_score, latency_ms, location, last_check, is_healthy, stability_percent, jitter_ms, download_speed_kbps, bandwidth_quality) VALUES ('$IP', $SCORE, $LAT, '$LOC', $TS, 1, $STAB, $JIT, $SPD, $BW) ON CONFLICT(ip_port) DO UPDATE SET total_score=$SCORE, latency_ms=$LAT, last_check=$TS, is_healthy=1, stability_percent=$STAB, jitter_ms=$JIT, download_speed_kbps=$SPD, bandwidth_quality=$BW;"
          
          # Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª
          RESP=$(curl -s -X POST "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/d1/database/$D1_DATABASE_ID/query" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "$(jq -n --arg sql "$SQL_CMD" '{sql: $sql}')")
            
          # Ø¨Ø±Ø±Ø³ÛŒ Ù†ØªÛŒØ¬Ù‡
          if echo "$RESP" | grep -q '"success":true'; then
            echo "âœ… Data synced successfully with Quantum Precision."
          else
            echo "âŒ Database Sync Failed. Response: $RESP"
            exit 1
          fi

      - name: ðŸ“Š Final Report
        if: always()
        run: |
          echo "## ðŸŒŒ Quantum AI Scan Report" >> $GITHUB_STEP_SUMMARY
          echo "**Selected Node:** `${{ steps.selection.outputs.best_ip }}`" >> $GITHUB_STEP_SUMMARY
          echo "**Latency:** ${{ steps.selection.outputs.latency }} ms (Ultra Low)" >> $GITHUB_STEP_SUMMARY
          echo "**AI Score:** ${{ steps.selection.outputs.score }}" >> $GITHUB_STEP_SUMMARY
          echo "**Stability:** ${{ steps.selection.outputs.stability }}%" >> $GITHUB_STEP_SUMMARY
          echo "Auto-generated by Quantum Engine ðŸš€" >> $GITHUB_STEP_SUMMARY
