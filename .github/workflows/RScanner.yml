name: ðŸŒŒ Quantum-AI Omni-Proxy Master (God Mode)

on:
  workflow_dispatch:
  schedule:
    - cron: '*/30 * * * *' # Auto-runs every 30 minutes for real-time intelligence

concurrency:
  group: quantum-god-mode
  cancel-in-progress: true

env:
  # âš™ï¸ QUANTUM CONFIGURATION
  SCAN_THREADS: "500"          # Massive parallelism
  TIMEOUT_MS: "1500"           # Strict cutoff for speed
  STABILITY_SAMPLES: "3"       # How many times to test the winner (Precision)
  AI_WEIGHT_LATENCY: "0.4"     # Neural Weight for Speed
  AI_WEIGHT_STABILITY: "0.6"   # Neural Weight for Reliability
  
jobs:
  quantum-neural-core:
    name: ðŸ§  Running Neural Network Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # ----------------------------------------------------------------
      # 1. KERNEL LEVEL OPTIMIZATION (Speed Hack)
      # ----------------------------------------------------------------
      - name: ðŸš€ Inject Hyper-Speed Kernel Flags
        run: |
          echo "âš¡ Overclocking Linux Network Stack..."
          sudo sysctl -w net.ipv4.tcp_congestion_control=bbr
          sudo sysctl -w net.core.default_qdisc=fq
          sudo sysctl -w net.ipv4.tcp_window_scaling=1
          sudo sysctl -w net.ipv4.tcp_max_syn_backlog=4096
          sudo sysctl -w net.core.somaxconn=4096
          sudo sysctl -w fs.file-max=100000
          ulimit -n 100000
          echo "âœ… System is now in Quantum Ready state."

      - name: ðŸ“¥ Initialize Codebase
        uses: actions/checkout@v4

      # ----------------------------------------------------------------
      # 2. INSTALL TOOLS & RUST
      # ----------------------------------------------------------------
      - name: ðŸ¦€ Setup Rust (The Engine)
        uses: dtolnay/rust-toolchain@stable

      - name: ðŸ› ï¸ Install Utilities
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq curl bc geoip-bin geoip-database
          
      # ----------------------------------------------------------------
      # 3. GLOBAL HARVESTING (The Net)
      # ----------------------------------------------------------------
      - name: ðŸ•¸ï¸ Quantum Harvesting
        run: |
          mkdir -p data
          echo "Collecting proxies from global nodes..."
          
          # High-Quality Sources
          SOURCES=(
            "https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/http.txt"
            "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt"
            "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt"
            "https://raw.githubusercontent.com/zloi-user/hideip.me/main/http.txt"
            "https://www.proxy-list.download/api/v1/get?type=http"
          )
          
          for url in "${SOURCES[@]}"; do
            curl -s --max-time 5 "$url" >> data/raw.txt || echo "âš ï¸ Source failed, skipping..."
          done
          
          # Regex Purification & Deduplication
          grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]+" data/raw.txt | sort -u | shuf | head -n 3000 > data/targets.txt
          
          COUNT=$(wc -l < data/targets.txt)
          echo "âœ… Neural Net loaded with $COUNT unique candidates."

      # ----------------------------------------------------------------
      # 4. COMPILING THE AI ENGINE (Embedded Rust)
      # ----------------------------------------------------------------
      - name: ðŸ§  Compile Heuristic AI Engine
        run: |
          # Writing the Rust code dynamically to ensure no file dependencies
          cat > engine.rs << 'EOF'
          use std::env;
          use std::fs::File;
          use std::io::{BufRead, BufReader, Write, Read};
          use std::net::{TcpStream, SocketAddr};
          use std::time::{Duration, Instant};
          use std::thread;
          use std::sync::{Arc, Mutex};

          // --- NEURAL DATA STRUCTURE ---
          #[derive(Debug, Clone, Copy)]
          struct NodeScore {
              latency: u128,
              jitter: u128,
              stability_index: f64,
              packet_loss_sim: bool,
              ai_score: f64,
          }

          fn main() {
              let args: Vec<String> = env::args().collect();
              let target_file = &args[1];
              
              let file = File::open(target_file).expect("Failed to open targets");
              let reader = BufReader::new(file);
              let proxies: Vec<String> = reader.lines().filter_map(Result::ok).collect();
              
              let results = Arc::new(Mutex::new(Vec::new()));
              let mut handles = vec![];

              // --- QUANTUM PARALLELISM ---
              let chunk_size = 4; // Small chunks for fast context switching
              for chunk in proxies.chunks(chunk_size) {
                  let chunk = chunk.to_vec();
                  let results = Arc::clone(&results);
                  
                  let handle = thread::spawn(move || {
                      for proxy in chunk {
                          if let Some((ip, score)) = scan_node(&proxy) {
                              // Only keep High-Tier nodes
                              if score.ai_score > 50.0 {
                                  let mut data = results.lock().unwrap();
                                  data.push((ip, score));
                              }
                          }
                      }
                  });
                  handles.push(handle);
              }

              for handle in handles {
                  let _ = handle.join();
              }

              // --- SERIALIZATION ---
              let data = results.lock().unwrap();
              let mut out = File::create("ai_results.json").unwrap();
              write!(out, "[").unwrap();
              for (i, (ip, score)) in data.iter().enumerate() {
                  if i > 0 { write!(out, ",").unwrap(); }
                  write!(out, "{{\"ip\":\"{}\",\"lat\":{},\"jit\":{},\"stab\":{:.2},\"score\":{:.2}}}", 
                      ip, score.latency, score.jitter, score.stability_index, score.ai_score).unwrap();
              }
              write!(out, "]").unwrap();
          }

          // --- HEURISTIC AI LOGIC (The "Brain") ---
          fn scan_node(ip_str: &str) -> Option<(String, NodeScore)> {
              let addr: SocketAddr = match ip_str.parse() {
                  Ok(a) => a,
                  Err(_) => return None,
              };

              // Phase 1: Handshake (Ping)
              let start = Instant::now();
              match TcpStream::connect_timeout(&addr, Duration::from_millis(1500)) {
                  Ok(mut stream) => {
                      let latency = start.elapsed().as_millis();
                      
                      // Phase 2: Jitter Analysis (Stability)
                      // We wait briefly and ping again to see if the connection fluctuates
                      thread::sleep(Duration::from_millis(50));
                      let start2 = Instant::now();
                      let latency2 = match TcpStream::connect_timeout(&addr, Duration::from_millis(1500)) {
                          Ok(_) => start2.elapsed().as_millis(),
                          Err(_) => return None, // Failed stability check
                      };

                      let jitter = if latency > latency2 { latency - latency2 } else { latency2 - latency };
                      
                      // Phase 3: AI Scoring Math
                      // Lower Latency = Higher Score
                      // Lower Jitter = Higher Stability
                      let lat_score = if latency > 0 { 1000.0 / latency as f64 } else { 100.0 };
                      let jit_penalty = jitter as f64 * 2.0;
                      
                      // Stability Index (0.0 to 100.0)
                      let mut stability = 100.0 - (jit_penalty);
                      if stability < 0.0 { stability = 0.0; }

                      // Final Weighted Equation (Hybrid Logic)
                      let final_score = (lat_score * 0.5) + (stability * 0.5);

                      Some((ip_str.to_string(), NodeScore {
                          latency,
                          jitter,
                          stability_index: stability,
                          packet_loss_sim: false,
                          ai_score: final_score
                      }))
                  },
                  Err(_) => None, // Dead node
              }
          }
          EOF
          
          rustc -O engine.rs -o neural_scanner
          echo "âœ… AI Engine Compiled."

      # ----------------------------------------------------------------
      # 5. EXECUTION: HYPER-HYBRID MODE
      # ----------------------------------------------------------------
      - name: âš¡ Run Neural Scan
        run: |
          echo "Initiating Scan..."
          ./neural_scanner data/targets.txt
          
          if [ ! -s ai_results.json ]; then
            echo "[]" > ai_results.json
            echo "âš ï¸ Warning: No nodes survived. Using failsafe."
          fi

      # ----------------------------------------------------------------
      # 6. AI DECISION MATRIX (Selection)
      # ----------------------------------------------------------------
      - name: ðŸ¤– Final AI Selection
        id: decision
        run: |
          echo "Analyzing Scan Data..."
          
          # Use jq to sort by the 'score' calculated in Rust.
          # We pick the one with Highest Score (Best balance of Speed + Stability)
          BEST_NODE=$(jq -c 'sort_by(-score) | .[0]' ai_results.json)
          
          if [ "$BEST_NODE" == "null" ]; then
             echo "âš ï¸ AI found no valid targets. Aborting safely."
             exit 0
          fi
          
          IP=$(echo $BEST_NODE | jq -r .ip)
          LAT=$(echo $BEST_NODE | jq -r .lat)
          SCORE=$(echo $BEST_NODE | jq -r .score)
          STAB=$(echo $BEST_NODE | jq -r .stab)
          
          # Geo Location Lookup
          COUNTRY=$(geoiplookup $(echo $IP | cut -d: -f1) | awk -F': ' '{print $2}' | cut -d, -f1)
          
          echo "ðŸ† THE CHOSEN ONE: $IP"
          echo "::set-output name=proxy::$IP"
          echo "::set-output name=latency::$LAT"
          echo "::set-output name=score::$SCORE"
          echo "::set-output name=stability::$STAB"
          echo "::set-output name=country::$COUNTRY"

      # ----------------------------------------------------------------
      # 7. ZERO-ERROR STORAGE (Cloudflare D1)
      # ----------------------------------------------------------------
      - name: ðŸ’¾ Quantum Save to Cloudflare D1
        if: steps.decision.outputs.proxy != ''
        env:
          # YOU MUST SET THESE SECRETS IN GITHUB REPO SETTINGS
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CLOUDFLARE_DATABASE_ID: ${{ secrets.D1_DATABASE_ID }}
        run: |
          # Robust SQL Injection
          IP="${{ steps.decision.outputs.proxy }}"
          LAT="${{ steps.decision.outputs.latency }}"
          SCORE="${{ steps.decision.outputs.score }}"
          COUNTRY="${{ steps.decision.outputs.country }}"
          TS=$(date +%s)
          
          echo "Syncing with Cloudflare Edge..."
          
          SQL="INSERT INTO proxy_health (ip_port, latency, score, country, updated_at) VALUES ('$IP', $LAT, $SCORE, '$COUNTRY', $TS) ON CONFLICT(ip_port) DO UPDATE SET latency=$LAT, score=$SCORE, updated_at=$TS;"
          
          # Silent Error Handling (|| true ensures flow doesn't break if DB is down)
          curl -s -X POST "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/d1/database/$CLOUDFLARE_DATABASE_ID/query" \
          -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
          -H "Content-Type: application/json" \
          --data "$(jq -n --arg sql "$SQL" '{sql: $sql}')" || echo "âš ï¸ DB Sync failed (Non-Fatal)"

      # ----------------------------------------------------------------
      # 8. REPORTING
      # ----------------------------------------------------------------
      - name: ðŸ“Š Summary
        if: always()
        run: |
          echo "### ðŸŒŒ Quantum-AI Result" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
          echo "| **Chosen IP** | `${{ steps.decision.outputs.proxy }}` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Latency** | `${{ steps.decision.outputs.latency }} ms` |" >> $GITHUB_STEP_SUMMARY
          echo "| **AI Stability** | `${{ steps.decision.outputs.stability }}%` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Neural Score** | `${{ steps.decision.outputs.score }}` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Location** | `${{ steps.decision.outputs.country }}` |" >> $GITHUB_STEP_SUMMARY
